---
title: "Varianzen: Invarianz, Kovarianz und Kontravarianz"
date: 2019-10-29 00:00:00
category: "Programmierung"
---

# Worum gehts?

Bei diesem Thema geht es darum in welcher Art und Weise generische Klassen untereinander kompatibel und zuweisbar sind.

Zugrunde liegt dem Ganzen die objektorientierte Vererbung und das damit verbundene Liskovsche Substitutionsprinzip (auch Ersetzungsprinzip genannt). Das Prinzip besagt, dass Objekte einer Oberklasse durch Objekte einer ihrer Unterklassen ersetzbar sein muss. Die Änderungen der Unterklassen dürfen also nur zusätzlicher Natur sein, sodass sie die Grundstruktur (der Oberklasse) nicht abändert und somit weiterhin kompatibel bleibt.

Im Zentrum der Varianzüberlegungen steht die Frage wie sich bei einer Vererbung die Typ-Kompatibilität in Argumenttypen und Rückgabetypen verhalten.

# Von der Invarianz über die Kovarianz zur Kontravarianz 

Der Einstieg erfolgt direkt mit einem kleinen Beispiel

```csharp
IList<string> hList = new List<string>();
IList<object> hListObj = hList; 	// Nope :/
```

Bei der Nutzung der generischen Klasse `List<>` schlägt die Zuweisung einer `string` Liste an eine `object` Liste fehl. Bei dieser Klasse ist nur die Zuweisung des gleichen Typs möglich. Diesen generischen Typparameter nennt man deshalb auch **invariant**.

Ab C# 4.0 und dem .NET Framework 4.0 wurde das ganze jedoch etwas aufgelockert. Ein Beispiel dafür ist folgendes:

```csharp
IEnumerable<string> hStrings = new List<string>();
IEnumerable<object> hObjects = hStrings;	// Yay :)
```

Bei dem generischen `IEnumerable` Interface ist diese Zuweisung möglich ohne die Typsicherheit zu verletzen. Einer Liste mit dem Basisdatentyp wird eine Liste mit einem abgeleiteten Typ zugewiesen. Möglich ist das durch die Nutzung der **Kovarianz**. 

Möglich ist das nur, weil der Typparameter in dem Interface `IEnumerable` nur als Rückgabewert verwendet wird. Bestehender Code welcher mit `IEnumerable<object>` arbeitet erwartet bei der Nutzung der Liste Werte vom Typ `object`. Wird die Liste `hObjects` jetzt so angepasst wird, dass sie auf Elemente des Typs `string` zeigt, führt das zu keinen weiteren Problemen, da `string` ein von `Object` abgeleiteter Typ ist und somit alle benötigten `object` Informationen inne hat. 

> In generischen Klassen wird die Kovarianz durch dass `out` Schlüsselwort beim Generischen Typparameter gekennzeichnet. Da sich die Kovarianz auf Rückgabewerte bezieht wird damit sichergestellt, dass in der generischen Klasse der Typparameter nur als Rückgabewert verwendet wird



Anders sieht das aus wenn der generische Typparameter  als Typ eines Methodenarguments verwendet wird.

```csharp
IList<string> hStrings = new List<string>();
IList<object> hObjects = hStrings; 	// Nope :/ könnte jetzt sonst alles andere reinkippen
```

Dieser Code schlägt zurecht fehl. Wir haben eine Liste die Elemente vom Typ `string` aufnehmen und verwalten kann. Mit der Zuweisung dieser Liste an `hObjects` sagt man, dass diese Liste Elemente vom Typ `object` verwalten könnte. Somit könnte man dann beliebige Typen in diese Liste hinzufügen, obwohl diese nur für `string` Elemente ausgelegt ist. Somit schlägt der Code zurecht fehl.



Wird der generische Typparameter als Typ für Methodenargumente verwendet ist jedoch die entgegengesetzte *Vererbungsrichtung* möglich. Eine generische Klasse die das erlaubt ist `Action`.

```csharp
Action<object> hBaseAction = new Action<object>();
Action<string> hStringAction = hBaseAction;		// Yay :)
```

In diesem Fall sagt man, dass `hBaseAction` mit Parametern vom Typ `object` umgehen kann. Weißt man dieses `Action` Objekt jetzt einer Referenz zu, die mit einem abgeleiteten Typ (`string`) arbeitet, stellt das kein Problem dar. Da die eigentliche Liste mit `object` Elementen arbeitet ist es ihr egal welche (von `object`) abgeleiteten Typen hinzugefügt werden. Das wird auch als **Kontravarianz** bezeichnet.

In generischen Strukturen wird die Kontravarianz durch das `in` Schlüsselwort beim generischen Typparameter gekennzeichnet. Die Klasse verpflichtet sich damit den generischen Typ nur als Eingabeparameter zu verwenden.